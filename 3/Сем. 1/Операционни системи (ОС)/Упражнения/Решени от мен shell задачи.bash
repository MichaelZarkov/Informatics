# Този файл не е предназначен за компилация.
# Този файл съдържа задачи за Linux shell команди с мои решения. Възможно е да има грешки.
# Автор Майкъл Зарков.
# Потребителското ми име е "s45655" - пиша го, за да няма объркване, защото в някои задачи се изисква. 

### COMMANDS ###

# Задача 0: Създайте файл permissions.txt в home директорията си. За него дайте единствено - read права на
# потребителя създал файла, write and exec на групата, read and exec на всички останали.
# Решение:
    cd ~
    touch permissions.txt
    chmod a+rwx permissions.txt
    chmod u-wx permissions.txt
    chmod g-r permissions.txt
    chmod o-w permissions.txt
    
# Задача 1: Намерете всички файлове в home директорията ви, които са променени в последния 1 час.
# Решение:
    find ~ -mindepth 1 -mmin -60
    # Обяснение:
    # '~' - home директорията ни.
    # '-mindepth 1' - за да не изкарва на екрана и самата home директория.
    # '-mmin -60' - изведи само тези, които са променени през последните 60 минути.
    # Забележка: 'find' всъщност прави DFS(depth first search) на дървото на файловата система с дадената 
    # папка корен. И '-mindepth 1' пропуска корена, защото той е на ниво 0.

# Задача 2: Копирайте /etc/services в home директорията си. Прочетете го с командата cat. (Ако този файл го 
# няма, прочетете с cat произволен текстов файл например /etc/passwd).
# Решение:
    cp /etc/services ~
    cat services

# Задача 3: Създайте symlink на файла /etc/passwd в home директорията ви (да се казва например passwd_symlink).
# Решение:
    ln /etc/passwd passwd_symlink -s
    
# Задача 4: Изведете всички обикновени ("regular") файлове, които /etc и нейните преки поддиректории съдържат.
# Решение:
    find /etc -mindepth 1 -maxdepth 2 -type f
    
# Задача 5: Изведете само първите 5 реда от /etc/services.
    head /etc/services -n 5
    
# Задача 6: Изведете всички преки поддиректории на /etc.
    find /etc -mindepth 1 -maxdepth 1 -type d
    
# Задача 7: Създайте файл, който да съдържа само последните 10 реда от изхода на 'Задача 6'.
# Решение:
    find /etc -mindepth 1 -maxdepth 1 -type d | head >> last-10-rows.txt
    # Обяснение: Командата 'find' ни намира нужните неща от 'Задача 6'. След това с оператора '|', 'head' поема
    # изхода на 'find' и взима само първите 10 реда от него. На края с оператора '>>' пренасочваме изхода на 'head'
    # към посочения файл.
    
# Задача 8: Изведете обикновените файлове по-големи от 42 байта в home директорията ви.
# Решение:
    find ~ -type f -size +42c
    
# Задача 9: Изведете всички обикновени файлове в директорията /tmp, които са от вашата група, които имат write права
# за достъп за група или за останалите(o=w).
    find /tmp -maxdepth 1 -type f -group students -perm  /g=w,o=w
    # Обяснение: 'students' е името на групата ми в университетския Линукс.
    # '-perm  /g=w,o=w' казва "дай ми файловете, които имат write permission за групата или за всички останали".
    
# Задача 10: Изведете всички файлове от <директория_по_избор>, които са по-нови от <файл_по_избор>.
# Решение:
    find <дир_по_избор> -newerBB <файл_по_избор>
    # Забележка: Това решение би трябвало да е вярно, но отбелязвам, че не всички инсталации на Линукс пазят времето на
    # създаването на файловете. Университетската инсталация не ги пази (до колкото разбирам) и затова ще изведе грешка.
    # Виж флага '-newerXY <reference_file>' за повече инфо за филтриране по време спрямо файл.

# Задача 11: Изтрийте файловете в home директорията си по-нови от някой определен файл (подайте на rm опция -i за да
# може да изберете само тези които искате да изтриете).
# Решение:
    find ~ -newerBB <файл_по_избор>  # Това го ползваме от предишната задача, за да ни изведе имената на по-новите
                                     # файлове от дадения.
    cd ~
    rm * -i  # Викаме 'rm' с wildcard патърна '*'. Шелът ще ни пита дали искаме да изтрием дадените файлове. С 'y'
             # потвърждаваме, а с кой да е друг бутон отхвърляме.

# Задача 12: Намерете файловете в /bin, които могат да се четат, пишат и изпълняват от всички.
# Решение:
    find /bin -mindepth 1 -maxdepth 1 -perm a=rwx

# Задача 13: Копирайте най-малкия файл от тези, намиращи се в /etc, в home директорията си.
# Решение:
    cd /etc
    cp $(ls /etc -S | tail -n 1) ~
     
# Задача 14:
# a) Копирайте всички файлове от /etc, които могат да се четат от всички, в директория myetc в home
#    директорията ви. Направете такава, ако нямате.
        mkdir myetc
        cp `find /etc -mindepth 1 -maxdepth 1 -type f -perm -a=r` myetc
        # 'find' намира нужните файлове и после с обратните кавички `` подаваме изхода на 'find' към 'cp', за да
        # копира намерените файлове в директорията 'myetc'.
# b) Когато вече сте получили myetc с файлове, архивирайте всички от тях, които започват с 'c' в архив, който се
#    казва 'c_start.tar'. Изтрийте директорията myetc и цялото ѝ съдържание, изтрийте архива 'c_start.tar'.
        cd ~/myetc
        tar --create --file=c_start.tar $(ls c*)  # Създаваме архива с имена започващи с 'c'.
        cd ~
        rm myetc -r
        
# Задача 15:
# Използвайки едно извикване на командата find, отпечатайте броя на редовете във всеки обикновен файл в /etc
# директорията.
    wc -l $(find /etc -mindepth 1 -maxdepth 1 -type f)  # Това е с едно викане на 'find', но има викане и на 'wc'.
                                                        # Брои ли се като решение?
                                                        


### PIPES ###

# Задача 0:
# Сортирайте /etc/passwd лексикографски по поле UserID.
    sort -k 3 -t : /etc/passwd
    # Забележка: разделителят на колоните е ':' и UserID е трета колона.
    # Ако се вгледаме в изхода на тази команда ще забележим, че редовете не са сортирани по нарастващ ред на
    # UserID-тата. Ще видим на пример, че 1145 е преди 92. Това е, защото подреждаме лексикографски и наистина
    # 1145 е преди 92 според лексикографската наредба (все пак това се иска в условието).
    # Ако искаме да подредим по големината на числата UserID, просто добавяме '-n':
    sort -n -k 3 -t : /etc/passwd
    
# Задача 1:
# Изведете само 1-ва и 5-та колона на файла /etc/passwd спрямо разделител ":".
    cut -d : -f 1,5 /etc/passwd
    
# Задача 2:
# Изведете съдържанието на файла /etc/passwd от 2-ри до 6-ти символ.
    head -c 6 /etc/passwd | tail -c 5
    # Забележка: това решение е вярно, само ако във файла всеки символ е точно един байт.
    # Алтернатива, която работи и с Unicode:
    file_as_string=$(cat /etc/passwd); printf "${file_as_string:1:5}\n"
    # Това на български казва:
    #   - сложи целия файл в променливата 'file_as_string'
    #   - после изведи 5 символа(не байта!) като започваш от позиция 1 и сложи нов ред на края за четимост.
    # 'printf' разбира от Unicode и знае как да извежда отделни символи дори да са по няколко байта.
    # Дори и да не е Unicode може да символът за нов ред да е два байта.
    
# Задача 3:
# Отпечатайте потребителските имена и техните home директории от /etc/passwd.
    cut -d : -f 1,6 /etc/passwd

# Задача 4:
# Отпечатайте втората колона на /etc/passwd, разделена спрямо символ '/'.
    cut -d/ -f2 /etc/passwd

# Задача 5:
# Изведете броя на байтовете, броя на символите и броя на редовете в /etc/passwd, заедно и по отделно.
    wc -c /etc/passwd  # Броят на байтовете.
    wc -m /etc/passwd  # Броят на символите.
    wc -l /etc/passwd  # Броят на редовете.
    wc /etc/passwd     # Бройките на трите.
    
# Задача 6:
# С отделни команди, извадете от файла /etc/passwd:
#   а) първите 12 реда.
#   б) първите 26 символа.
#   в) всички редове, освен последните 4.
#   г) последните 17 реда.
#   д) 76-я ред (или друг произволен, ако нямате достатъчно редове).
#   е) последните 4 символа от 13-ти ред (символът за нов ред не е част от реда).
    head -n12 /etc/passwd   # a)
    head -c 26 /etc/passwd  # б) - това работи, само ако във файла всеки символ е точно един байт.
    file_as_string=$(cat /etc/passwd); printf "${file_as_string:0:26}\n"  # б) - работи и с Unicode.
    head -n -4 /etc/passwd  # в)
    tail -n 17 /etc/passwd  # г)
    head -n 76 /etc/passwd | tail -n 1  # д)
    # е)
    temp_str=$(head -n 13 /etc/passwd | tail -n 1)  # Запази ред 13 в променлива.
    printf "${temp_str:(-4)}\n"  # Изведи последните 4 символа.
    
# Задача 7:
# Запаметете във файл в своята home директория резултатът от командата `df -P`.
# Напишете команда, която извежда на екрана съдържанието на този файл, без първия ред (хедъра), сортирано по второ поле (numeric).
    df -P > fileSystemUsage.txt
    tail -n +2 fileSystemUsage.txt | sort -n -k 2

# Задача 8:
# Запазете само потребителските имена от /etc/passwd във файл 'users' във вашата home директория.
    cut -d : -f 1 /etc/passwd > users
    
# Задача 9:
# Изпишете всички usernames от /etc/passwd с главни букви.
    VAR=$(cut -d : -f 1 /etc/passwd); echo "${VAR^^}"  # ^^ прави всички букви главни.
    
# Задача 10:
# а) Изведете реда от /etc/passwd, на който има информация за вашия потребител.
# б) Изведете този ред и двата реда преди него.
# в) Изведете този ред, двата преди него, и трите след него.
# д) Изведете *само* реда, който се намира 2 реда преди реда, съдържащ информация за вашия потребител.
    grep "s45655" /etc/passwd       # а) (s45655 е потребителското ми име)
    grep -B 2 "s45655" /etc/passwd  # б)
    grep -A 3 -B 2 "s45655" /etc/passwd  # в)
    grep -B 2 "s45655" /etc/passwd | head -n 1  # г)
    
# Задача 11:
# Изведете колко потребители не изпозват /bin/bash за login shell според /etc/passwd
# (hint: 'man 5 passwd' за информация какъв е форматът на /etc/passwd)
    cut -d : -f 7 /etc/passwd | grep -v "/bin/bash" | wc -l

# Задача 12:
# Изведете само имената на хората с второ име по-дълго от 6 (>6) символа според /etc/passwd.
    # Вариант 1 - извежда само фамилиите на хората.
    cut -d : -f 5 /etc/passwd | cut -d" " -f 2 | cut -d"," -f 1 | grep "[а-яА-Я]\{7,\}"
    # Вариант 2 - извежда име и фамилия.
    cut -d : -f 5 /etc/passwd | cut -d"," -f 1 | grep " [а-яА-Я]\{7,\}"
    
# Задача 13:
# Изведете имената на хората с първо име по-късо от 8 (<=7) символа според /etc/passwd.
    cut -d : -f 5 /etc/passwd | cut -d"," -f 1 | grep "^[а-яА-Я]\{1,7\} "

# Задача 14:
# Изведете целите редове от /etc/passwd за хората от предната задача.
    # Вариант 1 - филтрираме със списъка от имената, който ни дава предната задача.
    grep "$(cut -d : -f 5 /etc/passwd | cut -d"," -f 1 | grep "^[а-яА-Я]\{1,7\} ")" /etc/passwd
    # Вариант 2 - директно правим регулярен израз.
    grep ":[а-яА-Я]\{1,7\} " /etc/passwd
    
# Задача 15:
# Копирайте <РЕПО>/exercises/data/emp.data във вашата home директория.
# Посредством awk, използвайки копирания файл за входни данни, изведете:
#   01. общия брой редове
#   02. третия ред
#   03. последното поле от всеки ред
#   04. последното поле на последния ред
#   05. всеки ред, който има повече от 4 полета
#   06. всеки ред, чието последно поле е по-голямо от 4
#   07. общия брой полета във всички редове
#   08. броя редове, в които се среща низът Beth
#   09. най-голямото трето поле и редът, който го съдържа
#   10. всеки ред, който има поне едно поле
#   11. всеки ред, който има повече от 17 знака
#   12. броя на полетата във всеки ред и самият ред
#   13. първите две полета от всеки ред, с разменени места
#   14. всеки ред така, че първите две полета да са с разменени места
#   15. всеки ред така, че на мястото на първото поле да има номер на реда
#   16. всеки ред без второто поле
#   17. за всеки ред, сумата от второ и трето поле
#   18. сумата на второ и трето поле от всеки ред
# Файлът изглежда нещо от сорта на:
#   Beth    4.00    0
#   Dan     3.75    0
#   Kathy   4.00    10
#   Mark    5.00    20
#   Mary    5.50    22
#   Susie   4.25    18
    # 01 различни варианти:
    awk 'BEGIN { count = 0 } { ++count } END { print count }' emp.data  # с брояч
    awk 'END { print FNR }' emp.data  # с ползване на built-in variables
    # 02.
    awk 'BEGIN { cnt = 1 } { if (cnt == 3) { print $0; exit; } ++cnt }' emp.data
    awk '{ if (FNR == 3) { print $0; exit; }}' emp.data
    # 03. 
    awk '{ print $3 }' emp.data
    awk '{ print $NF }' emp.data
    # 04.
    awk 'END { print $0 }' emp.data
    # 05.
    awk '{ if (4 < NF) print $0 }' emp.data
    # 06.
    awk '{ if (4 < $NF) print $0 }' emp.data
    # 07.
    awk 'BEGIN { fcnt = 0 } { fcnt += NF } END { print fcnt }' emp.data
    # 08.
    awk '/Beth/ { ++cnt } END { print cnt }' emp.data
    # 09.
    # Забележи как може да се запише текущия ред в променлива - със var=substr($0, 0).
    awk 'max < $3 { max=$3; record=substr($0, 0) } END { print "Largest:", max; print record }' emp.data
    # 10.
    awk '0 < NF' emp.data
    # 11.
    awk '17 < length($0)' emp.data
    # 12.
    awk '{ print "Field count =", NF, $0 }' emp.data
    # 13.
    awk '{ print $2, $1 }' emp.data
    # 14.
    awk '{ print $2, $1, $3 }' emp.data
    # 15.
    awk '{ print FNR, "|", $2, $3 }' emp.data
    # 16.
    awk '{ print $1, $3 }' emp.data
    # 17. 
    awk '{ print ($2 + $3) }' emp.data
    # 18.
    awk '{ sum+= $2 + $3 } END { print sum }' emp.data
    
# Задача 16:
# Намерете само Group ID-то си от файлa /etc/passwd.
    grep "^s45655" /etc/passwd | cut -d":" -f 4

# Задача 17:
# Колко коментара има във файла "/etc/services"?
# Коментарите се маркират със символа #, след който всеки символ на реда се счита за коментар.
    grep -c "#" /etc/services  # Ако видиш символа '#' в ред, преброй го.
    
# Задача 18:
# Колко файлове в /bin са 'shell script'-oве? (Колко файлове в дадена директория са ASCII text?)
    cd /bin; awk -v total=0 '/^#!/ && FNR == 1 { ++total } END { print total }' $(ls /bin)
    # Това решение проверява дали първите два символа във всеки файл в /bin са "#!".
    # Защото shell скриптовете започват така. Може би има и по-добро решение.
    
# Задача 19:
# Направете списък с директориите на вашата файлова система, до които нямате достъп.
# Понеже файловата система може да е много голяма, търсете до 3 нива на дълбочина.
    find / -maxdepth 3 -false 2>&1 | cut -d" " -f 2 | cut -d":" -f 1
    # Пускаме find от корена "/" и извеждаме за кои директории е дало permission denied.
    # cut, за да извлечем само имената им.
    
# Задача 20:
# Създайте следната файлова йерархия в home директорията ви:
# dir5/file1
# dir5/file2
# dir5/file3
#
# Посредством vi въведете следното съдържание:
# file1:
1   
2
3
# file2:
s
a
d
f
# file3:
3
2
1
45
42
14
1
52
#
# Изведете на екрана:
#   1. статистика за броя редове, думи и символи за всеки един файл
#   2. статистика за броя редове и символи за всички файлове
#   3. общия брой редове на трите файла
    wc -l -w -m file1 file2 file3 | head -n 3  # 1.
    wc -l -m file1 file2 file3 | tail -n 1  # 2.
    wc -l $(ls ~/dir5) | tail -n 1 # 3.
    
# Задача 21:
# Във file2 (inplace) подменете всички малки букви с главни.
    printf "$(awk '{ print toupper($0) }' file2)" > file2
    # Това изглежда доста грозно.
    # Мисля, че със 'sed' може да се направи "по-хубаво".

# Задача 22:
# Във file3 (inplace) изтрийте всички "1"-ци.
    sed 's/1//' -i file3 

# Задача 23:
# Изведете статистика за най-често срещаните символи в трите файла.
    cd ~/dir5;
    for i in {33..126};  # For each printable character.
    do
        toChar=$(printf %b $(printf "\%o" $i));           # Convert 'i' to char.
        count=$(cat $(ls) | tr -c -d "$toChar" | wc -c);  # Count the occurrences of 'toChar' in all 3 files.
        if [ "$toChar" == "*" ]; then  # The space between [ and " is mandatory!
            printf "* %d\n" $count;    # Print * separately because it has special meaning.
        else 
            printf "%c %d\n" $toChar $count;
        fi
    done

# Задача 24:
# Направете нов файл с име по ваш избор, чието съдържание е конкатенирани съдържанията на file{1,2,3}.
    cd ~/dir5; cat $(ls) > fileConcat
    
# Задача 25:
# Прочетете текстов файл file1 и направете всички главни букви малки като запишете резултата във file2.
    printf "$(awk '{ print tolower($0) }' file1)" > file2
    
# Задача 25:
# Намерете броя на символите, различни от буквата 'а' във файла /etc/passwd. 
    tr -d 'a' < /etc/passwd | wc -c
    
# Задача 26:
# Намерете броя на уникалните символи, използвани в имената на потребителите от /etc/passwd.
# Забележка: приемам,че това означава да изброим колко различни символа се срещат в потребителските имена. 
# На пример, ако имаме имената "Иван София Мария", различните символи ще са 'ивансофямр' и значи броят им 
# ще е 10. 
    cut -d':' -f 1 /etc/passwd | fold -w 1 | sort | tr -d '\n' | tr -s -c '' | wc -c
    # Това сигурно може и по-четимо да се направи.
    # 1. Отделяме само потребителските имена от /etc/passwd.
    # 2. Правим така, че всеки символ да е на нов ред.
    # 3. Сортираме редовете (в случая символите).
    # 4. Махаме новите редове.
    # 5. Махаме повторенията (те., ако имаме "mmnnnpp" става "mnp").
    # 6. Броим кои символи са останали и това е нашият отговор.
   
# Задача 27:
# Отпечатайте всички редове на файла /etc/passwd, които не съдържат символния низ 'ов'.
    grep -v 'ов' /etc/passwd 
    
# Задача 28:
# Отпечатайте последната цифра на UID на всички редове между 28-ми и 46-ред в /etc/passwd.
    awk -F ':' '28 <= FNR && FNR <= 46 { print ($3 % 10) }' /etc/passwd

# Задача 29:
# Отпечатайте правата (permissions) и имената на всички файлове, до които имате read достъп, намиращи се в
# директорията /tmp (hint: 'man find', вижте -readable).
    find /tmp -mindepth 1 -maxdepth 1 -readable -printf "%M %f\n"
    # Интересно, че като го пуснах нямаше файлове с read достъп.
    # %M печата правата, %f печата името.
    
# Задача 30:
# Намерете имената на 10-те файла във вашата home директория, чието съдържание е редактирано най-скоро. На
# първо място трябва да бъде най-скоро редактираният файл. Намерете 10-те най-скоро достъпени файлове.
# (hint: Unix time)
    find ~ -mindepth 1 -printf "%T@ %p\n" | sort -k 1 -n -r | head | cut -f 2 -d' '  # recently edited
    find ~ -mindepth 1 -printf "%A@ %p\n" | sort -k 1 -n -r | head | cut -f 2 -d' '  # recently accessed
    # Извеждаме на стандартния изход съответно времето на последна/ен редакция/достъп и сортираме по него.

# Задача 30:
# Да приемем, че файловете, които съдържат C код, завършват на `.c` или `.h`. Колко на брой са те в
# директорията `/usr/include`? Колко реда C код има в тези файлове?
    ls /usr/include | awk '/\.c$/ || /\.h$/ { ++count } END { print count }'      # брой файлове
    cd /usr/include; wc -l $(ls /usr/include | awk '/\.c$/ || /\.h$/ { print }')  # брой редове
      
# Задача 31: 
# Даден ви е ASCII текстов файл - /etc/services. Отпечатайте хистограма на 10-те най-често срещани думи.
# Дума наричаме непразна последователност от букви. Не правим разлика между главни и малки букви.
# Хистограма наричаме поредица от редове, всеки от които има вида:
# <брой срещания> <какво се среща толкова пъти>
    # backslash казва на bash, че командата продължава на другия ред.
    # Какво точно правим:
    # 1. С grep изваждаме само думите от файла.
    # 2. Правим всички букви на малки и сортираме.
    # 3. С awk броим срещанията на всяка дума.
    # 4. Сортираме по броя на срещанията.
    grep -E -o '[a-zA-Z]+' /etc/services | awk '{ print tolower($0) }' | sort | \
    awk \
    '{                                                   
        if (prevWord == $0)
            ++count;
        else {
            if (count != 0)
                print count, prevWord;
            count=1;
            prevWord=$0;
        }
    }
    END { print count, prevWord; }' | \
    sort -k 1 -n -r | head
    
# Задача 32:
# Вземете факултетните номера на студентите (описани във файла <РЕПО>/exercises/data/mypasswd.txt)
# от СИ и ги запишете във файл si.txt сортирани.
# Студент е част от СИ, ако home директорията на този потребител (според <РЕПО>/exercises/data/mypasswd.txt)
# се намира в /home/SI директорията.
    # Изтегли файла.
    wget https://raw.githubusercontent.com/avelin/fmi-os/master/exercises/data/mypasswd.txt
    # Направи нужните трансформации.
    cut -f6 -d':' mypasswd.txt | cut -f3,4 -d'/' | grep -E '^SI/s[0-9]+' | cut -f2 -d's' | sort -n > si.txt

# Задача 32:
# За всяка група от /etc/group изпишете "Hello, <група>", като ако това е вашата група,
# напишете "Hello, <група> - I am here!".
    myGroupName=$(groups s45655 | cut -f3 -d' ') \
    awk -F: \
    'BEGIN {
        cmd = "echo $myGroupName";
        cmd | getline grName;
        close(cmd);
    }
    {
        if (grName == $1) print "Hello,", $1, "- I am here!";
        else              print "Hello,", $1;
    }' /etc/group

# Задача 33:
# Shell Script-овете са файлове, които по конвенция имат разширение .sh. Всеки такъв файл започва с
# "#!<interpreter>" , където <interpreter> указва на операционната система какъв интерпретатор да пусне
# (пр: "#!/bin/bash", "#!/usr/bin/python3 -u").
#
# Намерете всички .sh файлове в директорията `/usr` и нейните поддиректории, и
# проверете кой е най-често използваният интерпретатор.
    # Това е bash script.
        #!/bin/bash

        interpreters="$(head -q -n 1 $(find /usr -mindepth 1 -type f -regex ".*\.sh") | \
                      grep "^#!" | tr -d "#!" | sed "s/ *//";)";

        declare -A intrpCnt;  # Асоциативен списък.

        while read line;
        do
            intrpCnt["$line"]=$(( intrpCnt["$line"]+=1 ))
        done <<< $interpreters

        for key in "${!intrpCnt[@]}"
        do
            echo "Interpreter: $key | Number of users: ${intrpCnt[$key]}";
        done

    # За тестване. Трябва сборът от върнатите бройки да е равен на общия брой.
    # Връща общия брой shell скриптове.
    head -q -n 1 $(find /usr -mindepth 1 -type f -regex ".*\.sh") | grep "^#!" | wc -l

# Задача 34:
# 1. Изведете GID-овете на 5-те най-големи групи спрямо броя потребители, за които съответната група е
# основна (primary).
# 2. (*) Изведете имената на съответните групи.
# Hint: /etc/passwd, man 5 passwd
    # 1.
        #!/bin/bash
        GIDs="$(cut -f4 -d':' /etc/passwd)";
        declare -A arrGIDcounts;
        while read line;
        do
                arrGIDcounts["$line"]=$(( arrGIDcounts["$line"] + 1 ))
        done <<< $GIDs

        for key in "${!arrGIDcounts[@]}"
        do
                GIDcounts+=$(echo "Group $key|User_count ${arrGIDcounts[$key]}\n");
        done

        printf "$GIDcounts" | sort -r -d -t' ' -k3 | head -n5
    # 2.
    
