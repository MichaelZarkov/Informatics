# Уводни записки

## Лекция 1

**Представа за операционна система в тесен смисъл** - софтуер, който осигурява удобни абстракции за различните обекти, които ползват изчислителната система (хора, програми, други компютри). Този софтуер стои в (паметта) на изчислителната 
система през цялото време на работата - такива програми наричаме **резидентни** програми, които са активни през цялото време на работата на компютъра. Съвкупността от резидентните програми обикновено наричаме **ядро** (**kernal**) - ядрото изолира приложните програми (обикновените програми) от хардуера, то е връзката между двете. Като общи примери за "подсистеми" на ядрото имаме:
- мрежова подсистема (обслужва връзката с мрежата)
- файлова подсистема
- драйверите на кое да е устройство
- подсистема, която осигурява защитата на данните, правата на потребителите и изолацията на приложните програми една от друга, превключване на активността на приложните програми.
Операционната система си взаимодейства с програмите чрез точно определен дълготраен стандарт - най-често точно определени функции в дадения програмен език - тези функции се наричат **системни извиквания**. Тоест системните извиквания са точно API за ползване ресурсите на системата. В момента има два най-големи такива стандарта:
- POSIX - за всички операционни системи без Windows (като има разни варианти и версии). Например ос Linux, FreeBSD, MacOS, Android (вариант на Linux).
- Windows стандарт.
Ще изучаваме POSIX стандарта, защото е отворен (на Windows е затворен).

Ако пуснем само ядро на един компютър, нищо няма да можем да правим с него. Освен ядрото ни трябват и програми, които ни позволяват работим с него. Тези програми почти винаги идват заедно с ядрото и образуват **представата ни за операционна система в по-широк смисъл**. Тоест това е интерфейсът - два основни типа: команден и графичен (Apple популяризират графичния интерфейс с първата си основна операционна система през 1984 година). При командния интерфейс си взаимодействаме с компютъра чрез писане на текст в т-нар **терминал** или **конзола**. В Unix най-общо този интерфейс се нарича **shell** (shell идва от там, че обвива ядрото и ни позволява да го ползваме). Освен shell-а в Unix имаме и набор от прости програми за вършене на разни неща (наричат се core utils). Също в ос в широк смисъл обикновено има и редактори на съдържание (Notepad в Windows, VIM в Linux и д.р.), архивиране/разархивиране на файлове.

Скелета препоръчва Debian Linux ос.

**ОС в най-широк смисъл** - ядро + потребителски интерфейс + хранилище са софтуер специално пригодено за операционната система (като Play Store на Android или Apple Store на Apple). 

### Препоръчани книги

- The Mythical Man-Month - за процеса на разработка на първата операционна система. Счита се за уводна книга в софтуерното инженерство. Може поне страницата в Wikipedia да погледна.
- Modern operating systems 4th edition (Tatenbaum) - това е голяма книга, така че е по-подходяща като справочник, а не да се чете от край до край. Говори се за Unix.
- Operating system concepts (Abraham, Silberschatz) - също е голяма. Има сравнение на различните ОС.

## Лекция 2 - увод в shell

Програмите в shell обикновено работят като функции - подаваме им аргументи и те връщат резултат - като в повечето случаи данните са в текстов ви. Има и някои по-интерактивни например командата `top`, която показва в реално време натоварването на компютъра.

Основно на лекциите ще се занимаваме с процесите (задачи/tasks/processes) - как се представят като абстракции, как си взаимодействат, как си обменят информация помежду си. Също абстракциите комуникационни задачи. Процесите делим на две основни състояния - работещ процес и спящ процес (running and sleeping). В една система има много процеси дори нищо да не правим. Много от тези процеси наречени **демони** просто седят и чакат други програми да се възползват от техните услуги.
Работещите (running) процесите изпълняват някакво действие/изчисление (пишат по диска, нещо смятат) - имат нужда активно да ползват процесора. Спящите процеси нямат нужда да ползват процесорно време в точно този момент; най-често ОС приспива някой процес, когато чака да се извърши някаква входно-изходна операция (четене от клавиатура/мишка; четене от диск (дисковете са много по-бавни от процесорите)). Какво става, когато running процесите станат повече от ядрата на процесора? В модерните операционни системи операционната система дава на всеки процес малко време, в което да изпълнява действия, после го приспива и дава процесора на друг процес и така се създава илюзията, че всичко работи едновременно (и че имаме толкова ядра, колкото са работещите процеси). Такива ОС наричаме **ОС с времеделение**.

Казахме, че може да четем документацията в `man` страниците.

## Лекция 3

Да си прочета за обща култура: [Unix-philosophy]

Хумористична книга за неудобствата на ранния Unix: [Unix-haters-handbook]

Добри препоръки за правене на програми за Unix (философията на Unix):
1. Пишете програми, които правят едно нещо и го правят добре. Т.е. имат добре дефинирана конкретна функция и се изпълняват надеждно и бързо.
2. Пишете програмите да работят заедно - да могат да си комуникират със стандартни информационни канали. Например в Unix има тръби (pipes).
3. Пишете програмите да работят с текстови потоци, защото това е универсален интерфейс. Лесно се разбира и от хора и от компютри. HTML и XML с примери за данни в текстов вид.
4. Ортогоналност на програмите - функцията на различните програми да не се застъпва много-много.

Страничен коментар за инженерния подход и инженерното решение: при дадена задача добрият инженер трябва да може да я реши с вече наличните техники/ресурси/технологии, а не да измисля всичко наново, и само в случая, когато такива липсват, да измисля нови. Това важи за инженер в коя да е област.

#### Трите стандартни потока

В езика `C`, ако не е указано друго, една програма се стартира с 3 закачени потока към нея: stdin, stdout, stderr. Всяка програма в shell също следва този принцип. В shell по подразбиране входният поток е клавиатурата, изходният е терминалът и грешката също е терминалът. Направихме едни пример и за пренасочване на поток към файл. Ето малко повече инфо за [пренасочване и свързване на програми][IO-redirection-and-pipes]. Ползваме пренасочване например, за да пренасочим грешката към някакъв log файл и да го гледаме после при нужда.

## Лекция 4

Книжка за core utils програмките в Linux: [core-utils]; доста полезно четиво, има почти всичко, което ще учим на упражнения.

Официалният [GNU-bash-reference-manual].

Във втората част от курса ще е полезно да погледнем [GNU-C-tutorial] - за писане на програми на C, които ползват системните извиквания в Linux.

### Системни извиквания

Тук идеята за ортогоналността е много силно застъпена. За всяка дейност има по едно системно извикване.

### Shell

Общо взето гледахме от [GNU-bash-reference-manual].
- Можем да пускаме асинхронно програми (изпълнение във фонов режим) със символа `&`. Т.е. пускаме програмата в нов процес. Можем да прекратим работата на процеса с `kill <номер на процеса>`.
- Разгледахме:
  - различни оператори
  - return status
  - signal
- 3.1.1 Shell Operation
- 3.1.2 Quoting - подтискане на специалната интерпретация на специалните символи.
- 3.2 Shell Commands
- Изпълнение на команди; къде се търсят команди; променливата `PATH`; добавяне на директория в променливата `PATH`. Ако искаме да изпълним команда, която не е от `PATH` трябва да я опишем точно пътя до нея (къде се намира на диска).

[core-utils]: https://skelet.ludost.net/OS/misc/GNU_tutorials/coreutils.pdf "Често ползвани shell функции."

[GNU-bash-reference-manual]: https://skelet.ludost.net/OS/misc/GNU_tutorials/bashref.pdf

[GNU-C-tutorial]: https://skelet.ludost.net/OS/misc/GNU_tutorials/GNU_c_tutorial.pdf "Хубав учебник за C частта от курса."

[IO-redirection-and-pipes]: https://homepages.uc.edu/~thomam/Intro_Unix_Text/IO_Redir_Pipes.html

[Unix-haters-handbook]: ../Учебници%20и%20материали/The%20Unix-haters%20Handbook.pdf "Хумористично четиво."

[Unix-philosophy]: https://en.wikipedia.org/wiki/Unix_philosophy